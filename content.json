[{"title":"基于梯度的优化方法","date":"2017-08-11T06:30:30.000Z","path":"2017/08/11/algorithm-gradient-descent-method/","text":"最优化问题描述最优化问题广泛存在于学术研究和工程实际中。一个典型的最优化问题通常包括自变量、优化目标函数以及约束条件等等。机器学习作为一种热门的工程应用，通常包括模型、目标函数以及优化方法三个部分。一般而言，优化通常使用较为成熟的方法。本文重点介绍一些经典的优化算法，当目标函数是凸函数时，这些方法往往能得到全局最优解。 从数值迭代算法的角度考虑，不妨记当前时刻的估计为$\\mathbf{x}_k$，下一时刻的估计记为$\\mathbf{x}_{k+1}$，优化算法的一般形式记为：$$\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha \\Delta \\mathbf{x}$$其中$\\alpha &gt; 0$是步长，$\\Delta \\mathbf{x}$为迭代方向，各种优化方法的区别在于怎么选定迭代方向以及步长。根据原理不同，可将其总结为两大类：即一阶算法和二阶算法。一阶算法主要是梯度下降相关算法，二阶算法主要是牛顿法相关算法。 根据泰勒公式，可以将$f(\\mathbf{x}_{k+1})$在点$\\mathbf{x}_k$处展开为：$$\\begin{equation}f(\\mathbf{x}_{k+1}) = f(\\mathbf{x}_k) + \\alpha \\mathbf{g}_k^T \\Delta\\mathbf{x} + \\frac{\\alpha^2}{2} \\Delta \\mathbf{x}^T \\mathbf{H}_k \\Delta \\mathbf{x} + \\mathcal{o}(||\\Delta \\mathbf{x}||^2)\\end{equation} \\tag{1}$$上式中，$\\mathbf{g}_k = \\frac{\\partial f}{\\partial \\mathbf{x}}(\\mathbf{x}_k)$，表示一阶梯度向量，而$\\mathbf{H}_k$表示海森矩阵（Hessian matrix），$\\mathcal{o}(\\cdot)$表示参数的高阶无穷小。 一阶算法梯度下降算法对于任意函数，我们不妨取式$1$中右边的前两项，则可以得到：$$\\begin{equation}f(\\mathbf{x}_{k+1}) \\approx f(\\mathbf{x}_k) + \\alpha \\mathbf{g}_k^T \\Delta\\mathbf{x}\\end{equation} \\tag{2}$$由于我们的目标是最小化$f(\\mathbf{x})$，因此一个显然的迭代方向选择为$\\Delta \\mathbf{x} = -\\mathbf{g}_k$。根据向量内积，可以发现该方向是函数值下降最快的方向，据此可以得到梯度下降算法（又称最速下降法）如下： $$\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\alpha_k \\mathbf{g}_k$$考虑到上述推导依赖于泰勒展开近似，梯度下降算法在实际使用还需要考虑步长$\\alpha$的选择。步长如果选取的过大，则可能会导致函数值变大；如果选取的过小，则可能会导致收敛很慢。实际中通常选择衰减的步长，以符合误差的衰减。或者通过line search对步长进行进一步的优化：$$\\alpha^\\ast = \\underset{\\alpha}{\\operatorname{argmin}} {f(\\mathbf{x}_k - \\alpha \\mathbf{g}_k)}$$梯度下降算法适用于任何可微分的函数，并且可以求得该类函数的局部极小值。当函数不是处处可微时，通过次梯度下降算法（subgradient descent method）来求解，典型的该类函数是绝对值函数，次梯度下降算法的分析与梯度下降类似。 在机器学习领域，梯度下降算法的经典实现是随机梯度下降算法（Stochastic Gradient Descent，SGD），SGD通过随机采样一个或者一批（batch）样本，并计算其损失函数（全局损失函数可以拆分为所有样本损失函数之和）对应的梯度，以更新分类／回归模型的参数。在更大规模数据集中，SGD往往比经典的梯度下降收敛更快。 共轭梯度下降算法梯度方向虽然是函数值下降最快的方向，但是在实际使用中会存在以下问题：1）在最优解附近收敛变慢；2）如果函数存在特殊的梯度变化，会出现“之字形”走法（zigzag现象），导致收敛效率低。这类问题出现的原因在于在收敛过程中，梯度序列${\\mathbf{g}_0, …, \\mathbf{g}_{n-1}}$不是完全线性独立的，导致搜索的过程可能出现“undo”和“redo”现象，即单一方向的搜索没有走到尽头。假设仍然采用一阶算法的基本形式，在如下更新率下：$$\\mathbf{x}_{k+1} = \\mathbf{x}_{k} + \\alpha_k \\mathbf{d}_k$$为确保单一方向搜索到了尽头，则需要满足如下约束条件：$$\\mathbf{g}_{k+1}^T \\mathbf{d}_k = 0 \\tag{3}$$根据上式可以利用line search最小化$f(\\mathbf{x}_{k} + \\alpha \\mathbf{d}_k)$得到最优的步长，本质上该步长代表了误差$\\mathbf{e}_k = \\mathbf{x}^\\ast - \\mathbf{x}_k$在当前方向$\\mathbf{d}_k$上的投影长度。如果可以构建一组线性独立的基${\\mathbf{d}_0, …, \\mathbf{d}_{n-1}}$，将误差$\\mathbf{e}_k$投影到每个方向上，则可以避免“undo”和“redo”现象。以上分析表述了共轭梯度下降算法（Conjugate Gradient Descent，CGD）的基本思想。 循一般套路，本文先针对特殊的二次规划问题利用CGD给出确定优化算法，然后将其推广到一般的函数最小化问题。考虑如下标准无约束二次规划问题：$$\\min\\limits_{\\mathbf{x} \\in \\mathbb{R}^n}{f(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^T \\mathbf{H} \\mathbf{x} - \\mathbf{b}^T \\mathbf{x}}$$随机选定初始值$\\mathbf{x}_0$，并计算当前梯度$\\mathbf{g}_0 = \\mathbf{H}\\mathbf{x}_0 - \\mathbf{b}$，令$$\\mathbf{d}_0 = -\\mathbf{g}_0$$可以得到$\\mathbf{x}_1 = \\mathbf{x}_0 + \\alpha_0 \\mathbf{d}_0$。根据梯度表达式和更新公式可得$\\mathbf{g}_{1} = \\mathbf{g}_{0} + \\alpha_0 \\mathbf{H} \\mathbf{d}_0$根据式(3)，可以计算得到：$$\\alpha_0 = -\\frac{\\mathbf{g}_0^T \\mathbf{d}_0}{\\mathbf{d}_0^T\\mathbf{H}\\mathbf{d}_0} \\tag{4}$$至此我们得到了新的梯度向量$\\mathbf{g}_1$，根据Gram-Schmidt正交化方法的思想，我们希望迭代构造一组正交的基底，便于对误差进行分解。如果按照一般的正交化套路构造了一组基底${\\mathbf{d}_0, …, \\mathbf{d}_{n-1}}$，则可以得到在$\\mathbf{d}_k$上误差的投影长度为：$\\alpha_k = \\frac{\\mathbf{d}_k^T \\mathbf{e}_k}{\\mathbf{d}_k^T \\mathbf{e}_k}$。该种构造方法下，计算每个方向上的投影长度将需要知道$\\mathbf{e}_k = \\mathbf{x}^\\ast - \\mathbf{x}_k$的信息，构成了一个先有鸡还是先有蛋的问题。幸运的是，虽然不知道$\\mathbf{e}_k$但是很容易得到：$$\\mathbf{H} \\mathbf{e}_k = \\mathbf{H}(\\mathbf{x}^\\ast - \\mathbf{x}_k) = \\mathbf{b} - \\mathbf{H}\\mathbf{x}_k = -\\mathbf{g}_k$$上式启发我们使用一种新的“正交”基底，以使得误差可以通过当前梯度来反映。具体地，通过构造一组$H$-共轭（H-Conjugate，H矩阵对称正定）的基底，即：$$\\mathbf{d}_i^T \\mathbf{H} \\mathbf{d}_j = 0, \\forall i,j = 0, …, n-1, i \\neq j$$在该组基底下，我们接着式(4)构造新的搜索方向$\\mathbf{d}_1$，根据$\\mathbf{d}_1^T \\mathbf{H} \\mathbf{d}_0 = 0$，并结合$\\mathbf{d}_1 = -\\mathbf{g}_1 + \\beta_0 \\mathbf{d}_0$，可以解出：$$\\beta_0 = \\frac{\\mathbf{g}_1^T\\mathbf{H}\\mathbf{d}_0}{\\mathbf{d}_0^T\\mathbf{H}\\mathbf{d}_0} = \\frac{\\mathbf{g}_1^T \\mathbf{g}_1}{\\mathbf{g}_0^T \\mathbf{g}_0}$$上述算法迭代进行下去即可得到整个CGD算法，总结针对二次规划的CGD算法，可以发现如下事实： 存在如下正交以及$H$-共轭关系：$$\\mathbf{g}_i^T\\mathbf{g}_j = 0, \\mathbf{d}_i^T \\mathbf{H} \\mathbf{d}_j = 0, \\forall i,j = 0, …, n-1, i \\neq j$$ 对于正定二次规划问题，CGD可以在n步迭代后得到最优解，即$\\mathbf{x}_n = \\mathbf{x}^\\ast$； 与GD相比，针对二次规划的CGD算法也只需要使用一阶梯度信息，增加的计算量不大，但是大大加速了GD算法的收敛，达到了确定步数的收敛。 考虑到对任意函数进行二阶展开（参见式（1）），可以将CGD推广到任意函数最小化问题，得到如下Fletcher-Reeves算法：1234567891. 随机选择初始点$\\mathbf&#123;x&#125;_0$；2. 计算初始点梯度向量：$\\mathbf&#123;d&#125;_0 \\leftarrow -\\mathbf&#123;g&#125;_0$；3. 循环$k = 0,1,...,n-1$，进行如下操作： - 通过line search得到最小化$f(\\mathbf&#123;x&#125;_k + \\alpha \\mathbf&#123;d&#125;_k)$的$\\alpha_k$； - $\\mathbf&#123;x&#125;_&#123;k+1&#125; \\leftarrow \\mathbf&#123;x&#125;_k + \\alpha_k \\mathbf&#123;d&#125;_k$； - $\\beta_k \\leftarrow \\frac&#123;||\\mathbf&#123;g&#125;_&#123;k+1&#125;||^2&#125;&#123;||\\mathbf&#123;g&#125;_k||^2&#125;$； - $\\mathbf&#123;d&#125;_&#123;k+1&#125; \\leftarrow -\\mathbf&#123;g&#125;_k + \\beta_k \\mathbf&#123;d&#125;_k$；4. $\\mathbf&#123;x&#125;_0 \\leftarrow \\mathbf&#123;x&#125;_n$；5. 检查终止条件，如不满足，则跳到步骤2。 Fletcher-Reeves算法通过嵌套实现，每一个外层循环的第一步本质上都是梯度下降算法，剩余的$n-1$步可以保证函数值不会增加，因此其收敛可以很容易通过梯度下降算法证明。CGD算法仅仅使用了一阶梯度信息，但是大大加快了收敛速度，是针对任意函数的一个通用性强的高效优化算法。 二阶算法二阶算法利用二阶展开来近似任意函数，即取式（1）右边的前三项，可得：$$\\begin{equation}f(\\mathbf{x}_{k+1}) \\approx f(\\mathbf{x}_k) + \\alpha \\mathbf{g}_k^T \\Delta\\mathbf{x} + \\frac{\\alpha^2}{2} \\Delta\\mathbf{x}^T \\mathbf{H}_k\\Delta\\mathbf{x}\\end{equation} \\tag{4}$$ 牛顿法将式（4）看成一个以$\\alpha\\Delta\\mathbf{x}$为参数的函数，最小化该函数等价于求梯度为零的点，即：$$\\mathbf{H}_k (\\alpha\\Delta\\mathbf{x}) + \\mathbf{g}_k = 0$$从而可以得到下一步迭代的最优增量为：$\\alpha\\Delta\\mathbf{x} = -\\mathbf{H}_k^T \\mathbf{g}_k$。因此牛顿法可以总结为以下表达式：$$\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\mathbf{H}_k^T \\mathbf{g}_k$$从上式可以看出，牛顿法无需单独计算步长$\\alpha_k$，但是需要同时使用目标函数在当前点的一阶和二阶导数的信息，使得单步迭代的计算复杂度提升为$\\mathcal{O}(n^2)$。进一步地，牛顿法还需要计算Hessian矩阵的逆，使得复杂度进一步提升为$\\mathcal{O}(n^3)$。由于使用了二阶导数的信息，牛顿法可以很快一步找到二次规划问题的最优解。对于可以用二阶近似的函数，牛顿法也可以很快地找到最优解的近似。为了克服牛顿法需要计算Hessian矩阵逆的麻烦，出现了各种各样的拟牛顿法（Quasi-Newton method），不同的拟牛顿法的区别在于对Hessian矩阵及其逆的不同计算方法。在下面的介绍中，我们记Hessian矩阵$\\mathbf{H}_k$的近似逆矩阵为$\\mathbf{V}_k$。 拟牛顿法：DFP算法DFP算法的全称是Davidon–Fletcher–Powell算法，是史上第一个拟牛顿法。DFP最早由Davidon于1959年提出，经由Fletcher和Powell于1963年改进完善得到。DFP的核心思想是迭代估计$\\mathbf{V}_k$。对函数的梯度在当前点进行一阶展开，则有：$$\\mathbf{H}k \\mathbf{\\Delta \\mathbf{x}} = \\mathbf{g}{k+1} - \\mathbf{g}_k$$ 拟牛顿法：BFGS算法BFGS算法的全称是Broyden–Fletcher–Goldfarb–Shanno算法，是当前使用的主流优化算法，可以通过MATLAB的fminunc函数直接调用。 参考文献 Conjugate Gradient Method. http://web.cs.iastate.edu/~cs577/handouts/conjugate-gradient.pdf. Overview of conjugate gradient method. https://www.youtube.com/watch?v=eAYohMUpPMA.","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"}]},{"title":"算法-字符串模糊匹配-Google kickstart2017 Round A - Problem B","date":"2017-03-06T14:00:36.000Z","path":"2017/03/06/algorithm-google-kickstart2017-roundA-problemB/","text":"题目描述给定两个字符串，判断两个字符串是否匹配。字符串中出现的“*”可以匹配0-4个任意字符。比如如下输入样例： 3****ItShakes*eS*speareShakes*e*peare 对应的输出为： Case #1: TRUECase #2: TRUECase #3: FALSE 可能解法解决思路如下： 将原始字符串进行扩展，一个“*”替换成“****”; 建立二维数组match[i][j]，表示第一个字符串的[0,i]子串与第二个字符串的[0,j]是否匹配，由于*的存在，需要注意match数组存放的是； 动态规划求解，数组match的最后一个元素表示了是否匹配。动态规划的更新需要考虑一下两点： *可以匹配任何字符，但同时也可以不存在； 初值设置应该考虑特殊输入，比如空的字符串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int T; cin &gt;&gt; T; for (int Case = 1; Case &lt;= T; Case++) &#123; string first; string second; cin &gt;&gt; first; cin &gt;&gt; second; string firstc = \"#\"; string secondc = \"#\"; for (int i = 0;i &lt; first.size();i++)&#123; if (first[i] == '*') firstc += \"****\"; else firstc += first[i]; &#125; for (int i = 0;i &lt; second.size();i++)&#123; if (second[i] == '*') secondc += \"****\"; else secondc += second[i]; &#125; int m = firstc.size(); int n = secondc.size(); int match[m][n]; match[0][0] = 1; for (int i = 0;i &lt; m;i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if (i == 0 &amp;&amp; j == 0)&#123; match[i][j] = 1; &#125; else if (i == 0)&#123; match[i][j] = (secondc[j] == '*')?match[i][j-1]:0; &#125; else if (j == 0)&#123; match[i][j] = (firstc[i] == '*')?match[i-1][j]:0; &#125; else if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (firstc[i] == '*' || secondc[j] == '*' || firstc[i] == secondc[j]); if (firstc[i] == '*') match[i][j] = match[i][j] || match[i - 1][j]; if (secondc[j] == '*') match[i][j] = match[i][j] || match[i][j - 1]; &#125; &#125; &#125; if(match[m-1][n-1]) cout &lt;&lt; \"Case #\" &lt;&lt; Case &lt;&lt; \": \" &lt;&lt; \"TRUE\" &lt;&lt; endl; else cout &lt;&lt; \"Case #\" &lt;&lt; Case &lt;&lt; \": \" &lt;&lt; \"FALSE\" &lt;&lt; endl; &#125; return 0;&#125; 复杂度分析单次算法时间复杂度为$\\mathcal{O}(n^2)$，空间复杂度也为$\\mathcal{O}(n^2)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://vectorliu.com/tags/Google/"}]},{"title":"算法-数方块-Google kickstart2017 Round A - Problem A","date":"2017-03-05T08:00:36.000Z","path":"2017/03/05/algorithm-google-kickstart2017-roundA-problemA/","text":"题目描述给定一个r行c列的二维数组构成的矩形网格，该形状内存在多少个正方形。由于结果可能太大，将结果对$10^9 + 7 (1000000007)$取模输出。比如对于如下输入样例： 42 43 44 41000 500 对应输出如下： Case #1: 3Case #2: 10Case #3: 20Case #4: 624937395 可能解法首先观察下列$4 \\times 4$的网格图，对应边长为$3 \\times 3$： 我们可以发现： 边长为1的正方形有$(r - 1)(c - 1)$个； 边长为2的正方形有$(r - 2)(c - 2)$个，此外每个边长为2的正方形内部有一个斜的边长为$\\sqrt{2}$正方形，因此总数为$2(r - 2)(c - 2)$； 边长为3的正方形有$(r - 3)(c - 3)$个，此外每个边长为3的正方形内部有一个斜的边长为$\\sqrt{5}$正方形，因此总数为$3(r - 3)(c - 3)$； 边长为n的正方形及其内部的正方形共有$n(r - n)(c - n)$个。 同时，最大的边长n满足：$n = \\min \\lbrace r - 1, c - 1 \\rbrace$。据此已经可以通过循环求和得到结果，但是针对大样本时间会来不及。因此我们考虑自行化简如下：$$\\begin{align}\\\\&amp;\\sum\\limits_{i=1}^{n}{i(r - i)(c - i)}\\\\&amp;= rc \\cdot \\sum\\limits_{i=1}^{n}{i} - (r + c) \\cdot \\sum\\limits_{i=1}^{n}{i^2} + \\sum\\limits_{i=1}^{n}{i^3}\\\\&amp;= \\frac{n(n+1)}{2} \\cdot rc - \\frac{n(n+1)(2n+1)}{6} \\cdot (r+c) + \\frac{n^2(n+1)^2}{4}\\\\\\end{align}$$从而可以很方便的通过一次计算得到结果。最后，为了避免大数运算，需要在计算的过程中进行取模。要注意的是，由于中间有减法存在，需要检查最后的结果是否合法。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;fstream&gt;using namespace std;int main() &#123; int module = 1000000007; int T; cin &gt;&gt; T; for (int Case = 1; Case &lt;= T; Case++) &#123; int r, c; cin &gt;&gt; r &gt;&gt; c; long m = min(r - 1, c - 1); long sum = 0; long temp1 = r * c; long temp2 = r + c; sum += ((m + 1)*m/2 * temp1)%module; sum += -((int)(m + 1)*m*(2*m + 1)/6 *temp2)%module; sum += ((m + 1)*(m + 1)*m*m/4)%module; sum = sum%module; if(sum &lt; 0)&#123; sum += module; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; Case &lt;&lt; \": \" &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;&#125; 复杂度分析算法单次时间复杂度为$\\mathcal{O}(1)$，空间复杂度也为$\\mathcal{O}(1)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://vectorliu.com/tags/Google/"}]},{"title":"算法—分块最大值之差","date":"2017-03-05T02:44:30.000Z","path":"2017/03/05/algorithm-maximum-absolute-difference/","text":"题目描述给定一维数组arr，其下标范围为$[0, n-1]$，将数组分为两个部分$[0, k]$和$[k+1, n-1]$，两部分都非空。求前后两部分最大值的差的绝对值的最大值。 可能解法（python版）算法思想：首先，无论怎么分割，数组的全局最大值必然也是其中一部分的最大值。从数组头部开始看： 如果$arr[0] \\lt arr[1]$，则为保持左边的最大值最小，数组必须从从第一个元素后分段； 如果$arr[0] \\ge arr[1]$，则新加入的$arr[1]$对左边的最大值无影响，直到再次满足上一个条件。从尾部开始也可以得到类似的结论。因此，总结最大值之差的最大值满足如下表达式：$$\\max\\lbrace arr \\rbrace - \\min \\lbrace arr[0], arr[n - 1] \\rbrace.$$ 12345678def maxDiff(arr): n = len(arr) if len(arr) &lt; 2: return -1 maxVal = arr[0] for i in range(1, len(arr)): maxVal = arr[i] if maxVal &lt; arr[i] else maxVal return maxVal - min(arr[0], arr[n - 1]) 复杂度分析算法时间复杂度为$\\mathcal{O}(n)$，空间复杂度也为$\\mathcal{O}(N)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"}]},{"title":"算法-四等分数组-阿里2017年研发工程师JAVA（实习生）编程笔试","date":"2017-03-02T12:13:36.000Z","path":"2017/03/02/algorithm-four-equal-partition/","text":"题目描述给定一维数组arr，其元素都为正数，将其分为4个组，4个组的和分别相等，并且不包含分割位置的元素。判断给定数组是否符合该条件。 可能解法（python版）算法思想：将数组分为4个部分，共存在3个分界点。初始化3个分界点的合理位置，使得每一段都非空，同时初始化4个部分的和。从左边和右边开始扫描调整分界点位置，直到第1部分和第4部分相等。算法接着调整第2部分和第3部分，使得它们的部分和也相等。至此，可以比较第1段和第2段的和，如果满足第1段大于第2段，则不再有调整的可能，否则接着调整。算法利用了两个重要特征： 数组中所有元素都是正数，因此加上一个数不会变小； 第1段和第4段的和都是从小往大递增的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344def fourPartition(arr): first, second, third = 1, len(arr)/2, len(arr) - 2 sum1 = sum2 = sum3 = sum4 = 0 # requires only one sweep sum1 += sum(arr[0:first]) sum2 += sum(arr[(first + 1):second]) sum3 += sum(arr[(second + 1):third]) sum4 += sum(arr[third + 1:]) if sum1 * sum2 * sum3 * sum4 == 0: return False while(first &lt; second - 1) and (second &lt; third - 1): #sum1 and sum4, from small to large, until equal if sum1 &lt; sum4: sum1 += arr[first] sum2 -= arr[first + 1] first += 1 elif sum1 &gt; sum4: sum4 += arr[third] sum3 -= arr[third - 1] third -= 1 #sum1 == sum4 else: if sum2 &lt; sum3: sum2 += arr[second] sum3 -= arr[second + 1] second += 1 elif sum2 &gt; sum3: sum2 -= arr[second - 1] sum3 += arr[second] second -= 1 #sum2 == sum3 else: if sum1 &lt; sum2: sum1 += arr[first] sum2 -= arr[first + 1] first += 1 elif sum1 &gt; sum2: return False #sum1 == sum2 else: return True return False 复杂度分析算法时间复杂度为$\\mathcal{O}(n)$，空间复杂度也为$\\mathcal{O}(N)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"}]},{"title":"Hello World","date":"2017-03-02T12:13:36.000Z","path":"2017/03/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]