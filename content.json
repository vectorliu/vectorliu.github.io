[{"title":"算法—分块最大值之差","date":"2017-03-05T02:44:30.000Z","path":"2017/03/05/algorithm-maximum-absolute-difference/","text":"题目描述给定一维数组arr，其下标范围为$[0, n-1]$，将数组分为两个部分$[0, k]$和$[k+1, n-1]$，两部分都非空。求前后两部分最大值的差的绝对值的最大值。 可能解法（python版）算法思想：首先，无论怎么分割，数组的全局最大值必然也是其中一部分的最大值。从数组头部开始看： 如果$arr[0] \\lt arr[1]$，则为保持左边的最大值最小，数组必须从从第一个元素后分段； 如果$arr[0] \\ge arr[1]$，则新加入的$arr[1]$对左边的最大值无影响，直到再次满足上一个条件。从尾部开始也可以得到类似的结论。因此，总结最大值之差的最大值满足如下表达式：$$\\max\\lbrace arr \\rbrace - \\min \\lbrace arr[0], arr[n - 1] \\rbrace.$$ 12345678def maxDiff(arr): n = len(arr) if len(arr) &lt; 2: return -1 maxVal = arr[0] for i in range(1, len(arr)): maxVal = arr[i] if maxVal &lt; arr[i] else maxVal return maxVal - min(arr[0], arr[n - 1]) 复杂度分析算法时间复杂度为$\\mathcal{O}(n)$，空间复杂度也为$\\mathcal{O}(N)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"}]},{"title":"算法-四等分数组-阿里2017年研发工程师JAVA（实习生）编程笔试","date":"2017-03-02T12:13:36.000Z","path":"2017/03/02/algorithm-four-equal-partition/","text":"题目描述给定一维数组arr，其元素都为正数，将其分为4个组，4个组的和分别相等，并且不包含分割位置的元素。判断给定数组是否符合该条件。 可能解法（python版）算法思想：将数组分为4个部分，共存在3个分界点。初始化3个分界点的合理位置，使得每一段都非空，同时初始化4个部分的和。从左边和右边开始扫描调整分界点位置，直到第1部分和第4部分相等。算法接着调整第2部分和第3部分，使得它们的部分和也相等。至此，可以比较第1段和第2段的和，如果满足第1段大于第2段，则不再有调整的可能，否则接着调整。算法利用了两个重要特征： 数组中所有元素都是正数，因此加上一个数不会变小； 第1段和第4段的和都是从小往大递增的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344def fourPartition(arr): first, second, third = 1, len(arr)/2, len(arr) - 2 sum1 = sum2 = sum3 = sum4 = 0 # requires only one sweep sum1 += sum(arr[0:first]) sum2 += sum(arr[(first + 1):second]) sum3 += sum(arr[(second + 1):third]) sum4 += sum(arr[third + 1:]) if sum1 * sum2 * sum3 * sum4 == 0: return False while(first &lt; second - 1) and (second &lt; third - 1): #sum1 and sum4, from small to large, until equal if sum1 &lt; sum4: sum1 += arr[first] sum2 -= arr[first + 1] first += 1 elif sum1 &gt; sum4: sum4 += arr[third] sum3 -= arr[third - 1] third -= 1 #sum1 == sum4 else: if sum2 &lt; sum3: sum2 += arr[second] sum3 -= arr[second + 1] second += 1 elif sum2 &gt; sum3: sum2 -= arr[second - 1] sum3 += arr[second] second -= 1 #sum2 == sum3 else: if sum1 &lt; sum2: sum1 += arr[first] sum2 -= arr[first + 1] first += 1 elif sum1 &gt; sum2: return False #sum1 == sum2 else: return True return False 复杂度分析算法时间复杂度为$\\mathcal{O}(n)$，空间复杂度也为$\\mathcal{O}(N)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"}]},{"title":"Hello World","date":"2017-03-02T12:13:36.000Z","path":"2017/03/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]