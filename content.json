[{"title":"算法-字符串模糊匹配-Google kickstart2017 Round A - Problem B","date":"2017-03-06T14:00:36.000Z","path":"2017/03/06/algorithm-google-kickstart2017-roundA-problemB/","text":"题目描述给定两个字符串，判断两个字符串是否匹配。字符串中出现的“*”可以匹配0-4个任意字符。比如如下输入样例： 3****ItShakes*eS*speareShakes*e*peare 对应的输出为： Case #1: TRUECase #2: TRUECase #3: FALSE 可能解法解决思路如下： 将原始字符串进行扩展，一个“*”替换成“****”; 建立二维数组match[i][j]，表示第一个字符串的[0,i]子串与第二个字符串的[0,j]是否匹配； 动态规划求解，数组match的最后一个元素表示了是否匹配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int T; cin &gt;&gt; T; for (int Case = 1; Case &lt;= T; Case++) &#123; string first; string second; cin &gt;&gt; first; cin &gt;&gt; second; string firstc; string secondc; for (int i = 0;i &lt; first.size();i++)&#123; if (first[i] == '*') firstc += \"****\"; else firstc += first[i]; &#125; for (int i = 0;i &lt; second.size();i++)&#123; if (second[i] == '*') secondc += \"****\"; else secondc += second[i]; &#125; int m = firstc.size(); int n = secondc.size(); int match[m+1][n+1]; match[0][0] = 1; for (int i = 0;i &lt;= m;i++)&#123; for (int j = 0; j &lt;= n; j++)&#123; if (i &gt; 0 &amp;&amp; j &gt; 0)&#123; match[i][j] = match[i-1][j-1] &amp;&amp; (firstc[i] == '*' || secondc[j] == '*' || firstc[i] == secondc[j]); if(firstc[i-1] == '*') match[i][j] = match[i][j] || match[i-1][j]; if(secondc[j-1] == '*') match[i][j] = match[i][j] || match[i][j-1]; &#125; else&#123; if (i == 0 &amp;&amp; j &gt; 0)&#123; if (secondc[j-1] == '*') match[i][j] = match[i][j-1]; else match[i][j] = 0; &#125; if (i &gt; 0 &amp;&amp; j == 0)&#123; if (firstc[i-1] == '*') match[i][j] = match[i-1][j]; else match[i][j] = 0; &#125; &#125; &#125; &#125; if(match[m][n]) cout &lt;&lt; \"Case #\" &lt;&lt; Case &lt;&lt; \": \" &lt;&lt; \"TRUE\" &lt;&lt; endl; else cout &lt;&lt; \"Case #\" &lt;&lt; Case &lt;&lt; \": \" &lt;&lt; \"FALSE\" &lt;&lt; endl; &#125; return 0;&#125; 复杂度分析单次算法时间复杂度为$\\mathcal{O}(n^2)$，空间复杂度也为$\\mathcal{O}(n^2)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://vectorliu.com/tags/Google/"}]},{"title":"算法-数方块-Google kickstart2017 Round A - Problem A","date":"2017-03-05T08:00:36.000Z","path":"2017/03/05/algorithm-google-kickstart2017-roundA-problemA/","text":"题目描述给定一个r行c列的正方形组成的矩形，该形状内存在多少个正方形。 原题描述如下： Mr. Panda has recently fallen in love with a new game called Square Off, in which players compete to find as many different squares as possible on an evenly spaced rectangular grid of dots. To find a square, a player must identify four dots that form the vertices of a square. Each side of the square must have the same length, of course, but it does not matter what that length is, and the square does not necessarily need to be aligned with the axes of the grid. The player earns one point for every different square found in this way. Two squares are different if and only if their sets of four dots are different. Mr. Panda has just been given a grid with R rows and C columns of dots. How many different squares can he find in this grid? Since the number might be very large, please output the answer modulo $10^9 + 7 (1000000007)$. Input The first line of the input gives the number of test cases, T. T lines follow. Each line has two integers R and C: the number of dots in each row and column of the grid, respectively.Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of different squares can be found in the grid.Limits 1 ≤ T ≤ 100.Small dataset 2 ≤ R ≤ 1000.2 ≤ C ≤ 1000.Large dataset 2 ≤ R ≤ 109.2 ≤ C ≤ 109.Sample Input Output 42 43 44 41000 500 Case #1: 3Case #2: 10Case #3: 20Case #4: 624937395 可能解法首先观察下列$4 \\times 4$的网格图，对应边长为$3 \\times 3$： 我们可以发现： 边长为1的正方形有$(r - 1)(c - 1)$个； 边长为2的正方形有$(r - 2)(c - 2)$个，此外每个边长为2的正方形内部有一个斜的边长为$\\sqrt{2}$正方形，因此总数为$2(r - 2)(c - 2)$； 边长为3的正方形有$(r - 3)(c - 3)$个，此外每个边长为3的正方形内部有一个斜的边长为$\\sqrt{5}$正方形，因此总数为$3(r - 3)(c - 3)$； 边长为n的正方形及其内部的正方形共有$n(r - n)(c - n)$个。 同时，最大的边长n满足：$n = \\min \\lbrace r - 1, c - 1 \\rbrace$。据此已经可以通过循环求和得到结果，但是针对大样本时间会来不及。因此我们考虑自行化简如下：$$\\begin{align}\\\\&amp;\\sum\\limits_{i=1}^{n}{i(r - i)(c - i)}\\\\&amp;= rc \\cdot \\sum\\limits_{i=1}^{n}{i} - (r + c) \\cdot \\sum\\limits_{i=1}^{n}{i^2} + \\sum\\limits_{i=1}^{n}{i^3}\\\\&amp;= \\frac{n(n+1)}{2} \\cdot rc - \\frac{n(n+1)(2n+1)}{6} \\cdot (r+c) + \\frac{n^2(n+1)^2}{4}\\\\\\end{align}$$从而可以很方便的通过一次计算得到结果。最后，为了避免大数运算，需要在计算的过程中进行取模。要注意的是，由于中间有减法存在，需要检查最后的结果是否合法。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;fstream&gt;using namespace std;int main() &#123; ifstream fin; ofstream fout; fin.open(\"../A-large-practice.in\"); fout.open(\"../A-large.out\"); int module = 1000000007; int T; fin &gt;&gt; T; for (int Case = 1; Case &lt;= T; Case++) &#123; long long r, c; fin &gt;&gt; r &gt;&gt; c; long m = min(r - 1, c - 1); long sum = 0; long temp1 = r * c; long temp2 = r + c; sum += ((m + 1)*m/2 * temp1)%module; sum += -((int)(m + 1)*m*(2*m + 1)/6 *temp2)%module; sum += ((m + 1)*(m + 1)*m*m/4)%module; sum = sum%module; if(sum &lt; 0)&#123; sum += module; &#125; fout &lt;&lt; \"Case #\" &lt;&lt; Case &lt;&lt; \": \" &lt;&lt; sum &lt;&lt; endl; &#125; fin.close(); fout.close(); return 0;&#125;&#125; 复杂度分析算法时间复杂度为$\\mathcal{O}(T)$，空间复杂度也为$\\mathcal{O}(T)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"},{"name":"Google","slug":"Google","permalink":"http://vectorliu.com/tags/Google/"}]},{"title":"算法—分块最大值之差","date":"2017-03-05T02:44:30.000Z","path":"2017/03/05/algorithm-maximum-absolute-difference/","text":"题目描述给定一维数组arr，其下标范围为$[0, n-1]$，将数组分为两个部分$[0, k]$和$[k+1, n-1]$，两部分都非空。求前后两部分最大值的差的绝对值的最大值。 可能解法（python版）算法思想：首先，无论怎么分割，数组的全局最大值必然也是其中一部分的最大值。从数组头部开始看： 如果$arr[0] \\lt arr[1]$，则为保持左边的最大值最小，数组必须从从第一个元素后分段； 如果$arr[0] \\ge arr[1]$，则新加入的$arr[1]$对左边的最大值无影响，直到再次满足上一个条件。从尾部开始也可以得到类似的结论。因此，总结最大值之差的最大值满足如下表达式：$$\\max\\lbrace arr \\rbrace - \\min \\lbrace arr[0], arr[n - 1] \\rbrace.$$ 12345678def maxDiff(arr): n = len(arr) if len(arr) &lt; 2: return -1 maxVal = arr[0] for i in range(1, len(arr)): maxVal = arr[i] if maxVal &lt; arr[i] else maxVal return maxVal - min(arr[0], arr[n - 1]) 复杂度分析算法时间复杂度为$\\mathcal{O}(n)$，空间复杂度也为$\\mathcal{O}(N)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"}]},{"title":"算法-四等分数组-阿里2017年研发工程师JAVA（实习生）编程笔试","date":"2017-03-02T12:13:36.000Z","path":"2017/03/02/algorithm-four-equal-partition/","text":"题目描述给定一维数组arr，其元素都为正数，将其分为4个组，4个组的和分别相等，并且不包含分割位置的元素。判断给定数组是否符合该条件。 可能解法（python版）算法思想：将数组分为4个部分，共存在3个分界点。初始化3个分界点的合理位置，使得每一段都非空，同时初始化4个部分的和。从左边和右边开始扫描调整分界点位置，直到第1部分和第4部分相等。算法接着调整第2部分和第3部分，使得它们的部分和也相等。至此，可以比较第1段和第2段的和，如果满足第1段大于第2段，则不再有调整的可能，否则接着调整。算法利用了两个重要特征： 数组中所有元素都是正数，因此加上一个数不会变小； 第1段和第4段的和都是从小往大递增的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344def fourPartition(arr): first, second, third = 1, len(arr)/2, len(arr) - 2 sum1 = sum2 = sum3 = sum4 = 0 # requires only one sweep sum1 += sum(arr[0:first]) sum2 += sum(arr[(first + 1):second]) sum3 += sum(arr[(second + 1):third]) sum4 += sum(arr[third + 1:]) if sum1 * sum2 * sum3 * sum4 == 0: return False while(first &lt; second - 1) and (second &lt; third - 1): #sum1 and sum4, from small to large, until equal if sum1 &lt; sum4: sum1 += arr[first] sum2 -= arr[first + 1] first += 1 elif sum1 &gt; sum4: sum4 += arr[third] sum3 -= arr[third - 1] third -= 1 #sum1 == sum4 else: if sum2 &lt; sum3: sum2 += arr[second] sum3 -= arr[second + 1] second += 1 elif sum2 &gt; sum3: sum2 -= arr[second - 1] sum3 += arr[second] second -= 1 #sum2 == sum3 else: if sum1 &lt; sum2: sum1 += arr[first] sum2 -= arr[first + 1] first += 1 elif sum1 &gt; sum2: return False #sum1 == sum2 else: return True return False 复杂度分析算法时间复杂度为$\\mathcal{O}(n)$，空间复杂度也为$\\mathcal{O}(N)$。","tags":[{"name":"算法","slug":"算法","permalink":"http://vectorliu.com/tags/算法/"}]},{"title":"Hello World","date":"2017-03-02T12:13:36.000Z","path":"2017/03/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]